<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Tattvartha Code</title>
<meta name="keywords" content="">
<meta name="description" content="Title: &ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures&rdquo;
Date: 2025-02-03T12:00:00&#43;05:30
Author: &ldquo;Pralay Patoria&rdquo;
Tags: [&ldquo;C&#43;&#43;&rdquo;, &ldquo;Performance&rdquo;, &ldquo;Cache Optimization&rdquo;, &ldquo;Multi-Core Architectures&rdquo;]
Categories: [&ldquo;Low-Latency Programming&rdquo;, &ldquo;Computer Architecture&rdquo;]
Draft: true

Introduction
Modern multi-core processors use private caches to speed up data access and reduce latency. However, when multiple cores access the same memory locations, ensuring consistency across caches becomes crucial. Cache coherence ensures that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computation.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/cache_coherence_protocols/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/cache_coherence_protocols/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Tattvartha Code (Alt + H)">Tattvartha Code</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Welcome to TattvarthaCode">
                    <span>Welcome to TattvarthaCode</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;Â»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">4 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#why-are-cache-coherence-protocols-important" aria-label="Why Are Cache Coherence Protocols Important?">Why Are Cache Coherence Protocols Important?</a><ul>
                        
                <li>
                    <a href="#1-stale-reads-reader-writer-inconsistency" aria-label="1. Stale Reads (Reader-Writer Inconsistency)">1. Stale Reads (Reader-Writer Inconsistency)</a></li>
                <li>
                    <a href="#2-reordering-in-producer-consumer-patterns" aria-label="2. Reordering in Producer-Consumer Patterns">2. Reordering in Producer-Consumer Patterns</a></li>
                <li>
                    <a href="#3-broken-mutual-exclusion-locks-and-mutexes-failing" aria-label="3. Broken Mutual Exclusion (Locks and Mutexes Failing)">3. Broken Mutual Exclusion (Locks and Mutexes Failing)</a></li>
                <li>
                    <a href="#4-shared-data-structure-corruption-linked-lists-trees-buffers" aria-label="4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)">4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)</a></li>
                <li>
                    <a href="#5-preventing-stale-data" aria-label="5. Preventing Stale Data">5. Preventing Stale Data</a><ul>
                        
                <li>
                    <a href="#memory-visibility-and-ordering-issues" aria-label="Memory Visibility and Ordering Issues">Memory Visibility and Ordering Issues</a></li></ul>
                </li>
                <li>
                    <a href="#6-inconsistent-shared-data-structures-broken-linked-lists-trees-buffers" aria-label="6. Inconsistent Shared Data Structures (Broken Linked Lists, Trees, Buffers)">6. Inconsistent Shared Data Structures (Broken Linked Lists, Trees, Buffers)</a></li>
                <li>
                    <a href="#7-avoiding-data-races" aria-label="7. Avoiding Data Races">7. Avoiding Data Races</a></li>
                <li>
                    <a href="#8-maintaining-system-performance" aria-label="8. Maintaining System Performance">8. Maintaining System Performance</a><ul>
                        
                <li>
                    <a href="#81-avoiding-frequent-cache-misses" aria-label="8.1 Avoiding Frequent Cache Misses">8.1 Avoiding Frequent Cache Misses</a></li>
                <li>
                    <a href="#82-preventing-unnecessary-cache-invalidations" aria-label="8.2 Preventing Unnecessary Cache Invalidations">8.2 Preventing Unnecessary Cache Invalidations</a></li>
                <li>
                    <a href="#83-reducing-bus-contention-in-shared-memory-systems" aria-label="8.3 Reducing Bus Contention in Shared-Memory Systems">8.3 Reducing Bus Contention in Shared-Memory Systems</a></li>
                <li>
                    <a href="#84-optimized-synchronization-performance" aria-label="8.4 Optimized Synchronization Performance">8.4 Optimized Synchronization Performance</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><strong>Title</strong>: &ldquo;An Overview of Cache Coherence Protocols in Multi-Core Architectures&rdquo;<br>
<strong>Date</strong>: 2025-02-03T12:00:00+05:30<br>
<strong>Author</strong>: &ldquo;Pralay Patoria&rdquo;<br>
<strong>Tags</strong>: [&ldquo;C++&rdquo;, &ldquo;Performance&rdquo;, &ldquo;Cache Optimization&rdquo;, &ldquo;Multi-Core Architectures&rdquo;]<br>
<strong>Categories</strong>: [&ldquo;Low-Latency Programming&rdquo;, &ldquo;Computer Architecture&rdquo;]<br>
<strong>Draft</strong>: true</p>
<hr>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Modern multi-core processors use private caches to speed up data access and reduce latency. However, when multiple cores access the same memory locations, ensuring consistency across caches becomes crucial. <strong>Cache coherence</strong> ensures that all cores observe a consistent view of memory, preventing stale or incorrect data from affecting computation.</p>
<h2 id="why-are-cache-coherence-protocols-important">Why Are Cache Coherence Protocols Important?<a hidden class="anchor" aria-hidden="true" href="#why-are-cache-coherence-protocols-important">#</a></h2>
<p>Cache coherence protocols manage data consistency across private caches in multi-core systems. Without them, various issues arise:</p>
<h3 id="1-stale-reads-reader-writer-inconsistency">1. Stale Reads (Reader-Writer Inconsistency)<a hidden class="anchor" aria-hidden="true" href="#1-stale-reads-reader-writer-inconsistency">#</a></h3>
<ul>
<li><strong>Problem:</strong> One core writes a value while another core reads the same memory, but the reader sees an old value due to delayed cache updates.</li>
<li><strong>Example:</strong> A flag-based synchronization where the reader sees the flag but not the updated data.</li>
</ul>
<h3 id="2-reordering-in-producer-consumer-patterns">2. Reordering in Producer-Consumer Patterns<a hidden class="anchor" aria-hidden="true" href="#2-reordering-in-producer-consumer-patterns">#</a></h3>
<ul>
<li><strong>Problem:</strong> A producer writes data and then sets a flag, but the consumer sees the flag before the data update propagates.</li>
<li><strong>Example:</strong> A message queue where <code>msg.ready</code> is seen before <code>msg.payload</code> is updated.</li>
</ul>
<h3 id="3-broken-mutual-exclusion-locks-and-mutexes-failing">3. Broken Mutual Exclusion (Locks and Mutexes Failing)<a hidden class="anchor" aria-hidden="true" href="#3-broken-mutual-exclusion-locks-and-mutexes-failing">#</a></h3>
<ul>
<li><strong>Problem:</strong> A core locks a shared resource, but another core sees an old cached copy of the lock variable, causing multiple threads to enter a critical section.</li>
<li><strong>Example:</strong> A spinlock where both threads see <code>lock = false</code> due to stale cache.</li>
</ul>
<h3 id="4-shared-data-structure-corruption-linked-lists-trees-buffers">4. Shared Data Structure Corruption (Linked Lists, Trees, Buffers)<a hidden class="anchor" aria-hidden="true" href="#4-shared-data-structure-corruption-linked-lists-trees-buffers">#</a></h3>
<ul>
<li><strong>Problem:</strong> One core modifies a pointer-based data structure while another core reads it, leading to segmentation faults or undefined behavior.</li>
<li><strong>Example:</strong> A linked list where a node is deleted, but another thread still has an outdated pointer.</li>
</ul>
<h3 id="5-preventing-stale-data">5. Preventing Stale Data<a hidden class="anchor" aria-hidden="true" href="#5-preventing-stale-data">#</a></h3>
<p>Each core has a private cache to minimize access time. Without synchronization, a core might read <strong>outdated (stale) data</strong> modified by another core.</p>
<h4 id="memory-visibility-and-ordering-issues">Memory Visibility and Ordering Issues<a hidden class="anchor" aria-hidden="true" href="#memory-visibility-and-ordering-issues">#</a></h4>
<ul>
<li><strong>Problem:</strong> Updates to shared memory are not immediately visible to other cores, leading to inconsistencies.</li>
<li><strong>Effects:</strong>
<ul>
<li><strong>Stale Reads</strong> â A core sees an outdated value.</li>
<li><strong>Lost Updates</strong> â Multiple cores modify a variable, but some updates are lost.</li>
<li><strong>Synchronization Failures</strong> â Locks, mutexes, and atomic operations fail due to stale values.</li>
<li><strong>Reordering Issues</strong> â Dependent operations appear out of order.</li>
</ul>
</li>
<li><strong>Example:</strong>
<ul>
<li>Core 1 sets <code>lock = 1</code>, but Core 2 still sees <code>lock = 0</code>, breaking mutual exclusion.</li>
<li>Core 1 writes <code>data = 42</code>, then <code>ready = 1</code>, but Core 2 sees <code>ready = 1</code> before <code>data = 42</code>.</li>
</ul>
</li>
</ul>
<h3 id="6-inconsistent-shared-data-structures-broken-linked-lists-trees-buffers">6. Inconsistent Shared Data Structures (Broken Linked Lists, Trees, Buffers)<a hidden class="anchor" aria-hidden="true" href="#6-inconsistent-shared-data-structures-broken-linked-lists-trees-buffers">#</a></h3>
<ul>
<li><strong>Problem:</strong> Pointers or references to shared data structures become stale or inconsistent due to memory updates not propagating correctly.</li>
<li><strong>Example:</strong>
<ul>
<li>A node is deleted from a linked list, but another core still sees a stale pointer and follows it, leading to a segmentation fault.</li>
</ul>
</li>
</ul>
<h3 id="7-avoiding-data-races">7. Avoiding Data Races<a hidden class="anchor" aria-hidden="true" href="#7-avoiding-data-races">#</a></h3>
<p>Data races occur when multiple cores modify the same memory location simultaneously, leading to unpredictable behavior. Cache coherence protocols prevent such races by ensuring synchronized memory updates.</p>
<h3 id="8-maintaining-system-performance">8. Maintaining System Performance<a hidden class="anchor" aria-hidden="true" href="#8-maintaining-system-performance">#</a></h3>
<p>Cache coherence protocols balance data consistency and performance overhead. They aim to reduce unnecessary cache invalidations and updates, preserving cache efficiency while ensuring correctness.</p>
<p>By enforcing consistency across caches, cache coherence protocols prevent performance degradation and critical failures in multi-core systems.</p>
<h4 id="81-avoiding-frequent-cache-misses">8.1 Avoiding Frequent Cache Misses<a hidden class="anchor" aria-hidden="true" href="#81-avoiding-frequent-cache-misses">#</a></h4>
<ul>
<li><strong>With Cache Coherence:</strong> Ensures cores can access recent updates without fetching from main memory.</li>
<li><strong>Performance Benefit:</strong> Reduces latency due to fewer cache misses.</li>
</ul>
<h4 id="82-preventing-unnecessary-cache-invalidations">8.2 Preventing Unnecessary Cache Invalidations<a hidden class="anchor" aria-hidden="true" href="#82-preventing-unnecessary-cache-invalidations">#</a></h4>
<ul>
<li><strong>Optimized protocols like MESI</strong> reduce excessive invalidations, maintaining efficient cache usage.</li>
<li><strong>Performance Benefit:</strong> Avoids excessive cache flushing, improving data reuse.</li>
</ul>
<h4 id="83-reducing-bus-contention-in-shared-memory-systems">8.3 Reducing Bus Contention in Shared-Memory Systems<a hidden class="anchor" aria-hidden="true" href="#83-reducing-bus-contention-in-shared-memory-systems">#</a></h4>
<ul>
<li><strong>With Cache Coherence:</strong> Shared data can be accessed without multiple memory fetches.</li>
<li><strong>Performance Benefit:</strong> Reduces memory bus congestion, improving execution speed.</li>
</ul>
<h4 id="84-optimized-synchronization-performance">8.4 Optimized Synchronization Performance<a hidden class="anchor" aria-hidden="true" href="#84-optimized-synchronization-performance">#</a></h4>
<ul>
<li><strong>Without Cache Coherence:</strong> Locks and atomic operations require costly memory barriers.</li>
<li><strong>With Cache Coherence:</strong> Cache synchronization ensures faster lock acquisition and release.</li>
<li><strong>Performance Benefit:</strong> Multi-threaded applications see improved efficiency.</li>
</ul>
<p><strong>Example:</strong></p>
<ul>
<li><strong>Without cache coherence:</strong> Core 1 locks a shared resource (<code>lock = 1</code>), but Core 2 still sees <code>lock = 0</code>, causing multiple threads to enter a critical section.</li>
<li><strong>With cache coherence:</strong> The lock value is propagated correctly, ensuring mutual exclusion and correct execution.</li>
</ul>
<p><strong>Code Example (Using C++ Atomic Locks):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lock(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">critical_section</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (lock.exchange(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>memory_order_acquire) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; entered critical section</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    lock.store(<span style="color:#ae81ff">0</span>, std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(critical_section, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(critical_section, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This demonstrates how <strong>cache coherence</strong> ensures that all threads correctly see updates to the <code>lock</code> variable, preventing simultaneous access to the critical section.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/false_sharing_adjacent_variables/">
    <span class="title">Â« Prev</span>
    <br>
    <span>False Sharing Scenario: When Multiple Threads Modify Adjacent Variables</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/what_is_false_sharing/">
    <span class="title">Next Â»</span>
    <br>
    <span></span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Tattvartha Code</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
